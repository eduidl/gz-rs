// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc 3.12.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `gz/msgs/discovery.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
#[derive(::gz_msgs_common::GzMessage)]
// @@protoc_insertion_point(message:gz.msgs.Discovery)
pub struct Discovery {
    // message fields
    // @@protoc_insertion_point(field:gz.msgs.Discovery.header)
    pub header: ::protobuf::MessageField<super::header::Header>,
    // @@protoc_insertion_point(field:gz.msgs.Discovery.version)
    pub version: u32,
    // @@protoc_insertion_point(field:gz.msgs.Discovery.process_uuid)
    pub process_uuid: ::std::string::String,
    // @@protoc_insertion_point(field:gz.msgs.Discovery.type)
    pub type_: ::protobuf::EnumOrUnknown<discovery::Type>,
    // @@protoc_insertion_point(field:gz.msgs.Discovery.flags)
    pub flags: ::protobuf::MessageField<discovery::Flags>,
    // message oneof groups
    pub disc_contents: ::std::option::Option<discovery::Disc_contents>,
    // special fields
    // @@protoc_insertion_point(special_field:gz.msgs.Discovery.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Discovery {
    fn default() -> &'a Discovery {
        <Discovery as ::protobuf::Message>::default_instance()
    }
}

impl Discovery {
    pub fn new() -> Discovery {
        ::std::default::Default::default()
    }

    // .gz.msgs.Discovery.Subscriber sub = 6;

    pub fn sub(&self) -> &discovery::Subscriber {
        match self.disc_contents {
            ::std::option::Option::Some(discovery::Disc_contents::Sub(ref v)) => v,
            _ => <discovery::Subscriber as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_sub(&mut self) {
        self.disc_contents = ::std::option::Option::None;
    }

    pub fn has_sub(&self) -> bool {
        match self.disc_contents {
            ::std::option::Option::Some(discovery::Disc_contents::Sub(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sub(&mut self, v: discovery::Subscriber) {
        self.disc_contents = ::std::option::Option::Some(discovery::Disc_contents::Sub(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sub(&mut self) -> &mut discovery::Subscriber {
        if let ::std::option::Option::Some(discovery::Disc_contents::Sub(_)) = self.disc_contents {
        } else {
            self.disc_contents = ::std::option::Option::Some(discovery::Disc_contents::Sub(discovery::Subscriber::new()));
        }
        match self.disc_contents {
            ::std::option::Option::Some(discovery::Disc_contents::Sub(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sub(&mut self) -> discovery::Subscriber {
        if self.has_sub() {
            match self.disc_contents.take() {
                ::std::option::Option::Some(discovery::Disc_contents::Sub(v)) => v,
                _ => panic!(),
            }
        } else {
            discovery::Subscriber::new()
        }
    }

    // .gz.msgs.Discovery.Publisher pub = 7;

    pub fn pub_(&self) -> &discovery::Publisher {
        match self.disc_contents {
            ::std::option::Option::Some(discovery::Disc_contents::Pub(ref v)) => v,
            _ => <discovery::Publisher as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_pub_(&mut self) {
        self.disc_contents = ::std::option::Option::None;
    }

    pub fn has_pub(&self) -> bool {
        match self.disc_contents {
            ::std::option::Option::Some(discovery::Disc_contents::Pub(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pub(&mut self, v: discovery::Publisher) {
        self.disc_contents = ::std::option::Option::Some(discovery::Disc_contents::Pub(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pub(&mut self) -> &mut discovery::Publisher {
        if let ::std::option::Option::Some(discovery::Disc_contents::Pub(_)) = self.disc_contents {
        } else {
            self.disc_contents = ::std::option::Option::Some(discovery::Disc_contents::Pub(discovery::Publisher::new()));
        }
        match self.disc_contents {
            ::std::option::Option::Some(discovery::Disc_contents::Pub(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pub_(&mut self) -> discovery::Publisher {
        if self.has_pub() {
            match self.disc_contents.take() {
                ::std::option::Option::Some(discovery::Disc_contents::Pub(v)) => v,
                _ => panic!(),
            }
        } else {
            discovery::Publisher::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::header::Header>(
            "header",
            |m: &Discovery| { &m.header },
            |m: &mut Discovery| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &Discovery| { &m.version },
            |m: &mut Discovery| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "process_uuid",
            |m: &Discovery| { &m.process_uuid },
            |m: &mut Discovery| { &mut m.process_uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Discovery| { &m.type_ },
            |m: &mut Discovery| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, discovery::Flags>(
            "flags",
            |m: &Discovery| { &m.flags },
            |m: &mut Discovery| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, discovery::Subscriber>(
            "sub",
            Discovery::has_sub,
            Discovery::sub,
            Discovery::mut_sub,
            Discovery::set_sub,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, discovery::Publisher>(
            "pub",
            Discovery::has_pub,
            Discovery::pub_,
            Discovery::mut_pub,
            Discovery::set_pub,
        ));
        oneofs.push(discovery::Disc_contents::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Discovery>(
            "Discovery",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Discovery {
    const NAME: &'static str = "Discovery";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                16 => {
                    self.version = is.read_uint32()?;
                },
                26 => {
                    self.process_uuid = is.read_string()?;
                },
                32 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.flags)?;
                },
                50 => {
                    self.disc_contents = ::std::option::Option::Some(discovery::Disc_contents::Sub(is.read_message()?));
                },
                58 => {
                    self.disc_contents = ::std::option::Option::Some(discovery::Disc_contents::Pub(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.version);
        }
        if !self.process_uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.process_uuid);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(discovery::Type::UNINITIALIZED) {
            my_size += ::protobuf::rt::int32_size(4, self.type_.value());
        }
        if let Some(v) = self.flags.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.disc_contents {
            match v {
                &discovery::Disc_contents::Sub(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &discovery::Disc_contents::Pub(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.version != 0 {
            os.write_uint32(2, self.version)?;
        }
        if !self.process_uuid.is_empty() {
            os.write_string(3, &self.process_uuid)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(discovery::Type::UNINITIALIZED) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let Some(v) = self.flags.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.disc_contents {
            match v {
                &discovery::Disc_contents::Sub(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &discovery::Disc_contents::Pub(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Discovery {
        Discovery::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.version = 0;
        self.process_uuid.clear();
        self.type_ = ::protobuf::EnumOrUnknown::new(discovery::Type::UNINITIALIZED);
        self.flags.clear();
        self.disc_contents = ::std::option::Option::None;
        self.disc_contents = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Discovery {
        static instance: Discovery = Discovery {
            header: ::protobuf::MessageField::none(),
            version: 0,
            process_uuid: ::std::string::String::new(),
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            flags: ::protobuf::MessageField::none(),
            disc_contents: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Discovery {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Discovery").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Discovery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Discovery {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Discovery`
pub mod discovery {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:gz.msgs.Discovery.disc_contents)
    pub enum Disc_contents {
        // @@protoc_insertion_point(oneof_field:gz.msgs.Discovery.sub)
        Sub(Subscriber),
        // @@protoc_insertion_point(oneof_field:gz.msgs.Discovery.pub)
        Pub(Publisher),
    }

    impl ::protobuf::Oneof for Disc_contents {
    }

    impl ::protobuf::OneofFull for Disc_contents {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::Discovery as ::protobuf::MessageFull>::descriptor().oneof_by_name("disc_contents").unwrap()).clone()
        }
    }

    impl Disc_contents {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Disc_contents>("disc_contents")
        }
    }
    #[derive(PartialEq,Clone,Default,Debug)]
    #[derive(::gz_msgs_common::GzMessage)]
    // @@protoc_insertion_point(message:gz.msgs.Discovery.Flags)
    pub struct Flags {
        // message fields
        // @@protoc_insertion_point(field:gz.msgs.Discovery.Flags.relay)
        pub relay: bool,
        // @@protoc_insertion_point(field:gz.msgs.Discovery.Flags.no_relay)
        pub no_relay: bool,
        // special fields
        // @@protoc_insertion_point(special_field:gz.msgs.Discovery.Flags.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Flags {
        fn default() -> &'a Flags {
            <Flags as ::protobuf::Message>::default_instance()
        }
    }

    impl Flags {
        pub fn new() -> Flags {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "relay",
                |m: &Flags| { &m.relay },
                |m: &mut Flags| { &mut m.relay },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "no_relay",
                |m: &Flags| { &m.no_relay },
                |m: &mut Flags| { &mut m.no_relay },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Flags>(
                "Discovery.Flags",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Flags {
        const NAME: &'static str = "Flags";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.relay = is.read_bool()?;
                    },
                    16 => {
                        self.no_relay = is.read_bool()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.relay != false {
                my_size += 1 + 1;
            }
            if self.no_relay != false {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.relay != false {
                os.write_bool(1, self.relay)?;
            }
            if self.no_relay != false {
                os.write_bool(2, self.no_relay)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Flags {
            Flags::new()
        }

        fn clear(&mut self) {
            self.relay = false;
            self.no_relay = false;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Flags {
            static instance: Flags = Flags {
                relay: false,
                no_relay: false,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Flags {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Discovery.Flags").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Flags {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Flags {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    #[derive(::gz_msgs_common::GzMessage)]
    // @@protoc_insertion_point(message:gz.msgs.Discovery.Subscriber)
    pub struct Subscriber {
        // message fields
        // @@protoc_insertion_point(field:gz.msgs.Discovery.Subscriber.topic)
        pub topic: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:gz.msgs.Discovery.Subscriber.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Subscriber {
        fn default() -> &'a Subscriber {
            <Subscriber as ::protobuf::Message>::default_instance()
        }
    }

    impl Subscriber {
        pub fn new() -> Subscriber {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "topic",
                |m: &Subscriber| { &m.topic },
                |m: &mut Subscriber| { &mut m.topic },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Subscriber>(
                "Discovery.Subscriber",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Subscriber {
        const NAME: &'static str = "Subscriber";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.topic = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.topic.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.topic);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.topic.is_empty() {
                os.write_string(1, &self.topic)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Subscriber {
            Subscriber::new()
        }

        fn clear(&mut self) {
            self.topic.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Subscriber {
            static instance: Subscriber = Subscriber {
                topic: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Subscriber {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Discovery.Subscriber").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Subscriber {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Subscriber {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    #[derive(::gz_msgs_common::GzMessage)]
    // @@protoc_insertion_point(message:gz.msgs.Discovery.Publisher)
    pub struct Publisher {
        // message fields
        // @@protoc_insertion_point(field:gz.msgs.Discovery.Publisher.topic)
        pub topic: ::std::string::String,
        // @@protoc_insertion_point(field:gz.msgs.Discovery.Publisher.address)
        pub address: ::std::string::String,
        // @@protoc_insertion_point(field:gz.msgs.Discovery.Publisher.process_uuid)
        pub process_uuid: ::std::string::String,
        // @@protoc_insertion_point(field:gz.msgs.Discovery.Publisher.node_uuid)
        pub node_uuid: ::std::string::String,
        // @@protoc_insertion_point(field:gz.msgs.Discovery.Publisher.scope)
        pub scope: ::protobuf::EnumOrUnknown<publisher::Scope>,
        // message oneof groups
        pub pub_type: ::std::option::Option<publisher::Pub_type>,
        // special fields
        // @@protoc_insertion_point(special_field:gz.msgs.Discovery.Publisher.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Publisher {
        fn default() -> &'a Publisher {
            <Publisher as ::protobuf::Message>::default_instance()
        }
    }

    impl Publisher {
        pub fn new() -> Publisher {
            ::std::default::Default::default()
        }

        // .gz.msgs.Discovery.Publisher.MessagePublisher msg_pub = 6;

        pub fn msg_pub(&self) -> &publisher::MessagePublisher {
            match self.pub_type {
                ::std::option::Option::Some(publisher::Pub_type::MsgPub(ref v)) => v,
                _ => <publisher::MessagePublisher as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_msg_pub(&mut self) {
            self.pub_type = ::std::option::Option::None;
        }

        pub fn has_msg_pub(&self) -> bool {
            match self.pub_type {
                ::std::option::Option::Some(publisher::Pub_type::MsgPub(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_msg_pub(&mut self, v: publisher::MessagePublisher) {
            self.pub_type = ::std::option::Option::Some(publisher::Pub_type::MsgPub(v))
        }

        // Mutable pointer to the field.
        pub fn mut_msg_pub(&mut self) -> &mut publisher::MessagePublisher {
            if let ::std::option::Option::Some(publisher::Pub_type::MsgPub(_)) = self.pub_type {
            } else {
                self.pub_type = ::std::option::Option::Some(publisher::Pub_type::MsgPub(publisher::MessagePublisher::new()));
            }
            match self.pub_type {
                ::std::option::Option::Some(publisher::Pub_type::MsgPub(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_msg_pub(&mut self) -> publisher::MessagePublisher {
            if self.has_msg_pub() {
                match self.pub_type.take() {
                    ::std::option::Option::Some(publisher::Pub_type::MsgPub(v)) => v,
                    _ => panic!(),
                }
            } else {
                publisher::MessagePublisher::new()
            }
        }

        // .gz.msgs.Discovery.Publisher.ServicePublisher srv_pub = 7;

        pub fn srv_pub(&self) -> &publisher::ServicePublisher {
            match self.pub_type {
                ::std::option::Option::Some(publisher::Pub_type::SrvPub(ref v)) => v,
                _ => <publisher::ServicePublisher as ::protobuf::Message>::default_instance(),
            }
        }

        pub fn clear_srv_pub(&mut self) {
            self.pub_type = ::std::option::Option::None;
        }

        pub fn has_srv_pub(&self) -> bool {
            match self.pub_type {
                ::std::option::Option::Some(publisher::Pub_type::SrvPub(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_srv_pub(&mut self, v: publisher::ServicePublisher) {
            self.pub_type = ::std::option::Option::Some(publisher::Pub_type::SrvPub(v))
        }

        // Mutable pointer to the field.
        pub fn mut_srv_pub(&mut self) -> &mut publisher::ServicePublisher {
            if let ::std::option::Option::Some(publisher::Pub_type::SrvPub(_)) = self.pub_type {
            } else {
                self.pub_type = ::std::option::Option::Some(publisher::Pub_type::SrvPub(publisher::ServicePublisher::new()));
            }
            match self.pub_type {
                ::std::option::Option::Some(publisher::Pub_type::SrvPub(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_srv_pub(&mut self) -> publisher::ServicePublisher {
            if self.has_srv_pub() {
                match self.pub_type.take() {
                    ::std::option::Option::Some(publisher::Pub_type::SrvPub(v)) => v,
                    _ => panic!(),
                }
            } else {
                publisher::ServicePublisher::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "topic",
                |m: &Publisher| { &m.topic },
                |m: &mut Publisher| { &mut m.topic },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "address",
                |m: &Publisher| { &m.address },
                |m: &mut Publisher| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "process_uuid",
                |m: &Publisher| { &m.process_uuid },
                |m: &mut Publisher| { &mut m.process_uuid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "node_uuid",
                |m: &Publisher| { &m.node_uuid },
                |m: &mut Publisher| { &mut m.node_uuid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "scope",
                |m: &Publisher| { &m.scope },
                |m: &mut Publisher| { &mut m.scope },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, publisher::MessagePublisher>(
                "msg_pub",
                Publisher::has_msg_pub,
                Publisher::msg_pub,
                Publisher::mut_msg_pub,
                Publisher::set_msg_pub,
            ));
            fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, publisher::ServicePublisher>(
                "srv_pub",
                Publisher::has_srv_pub,
                Publisher::srv_pub,
                Publisher::mut_srv_pub,
                Publisher::set_srv_pub,
            ));
            oneofs.push(publisher::Pub_type::generated_oneof_descriptor_data());
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Publisher>(
                "Discovery.Publisher",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Publisher {
        const NAME: &'static str = "Publisher";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.topic = is.read_string()?;
                    },
                    18 => {
                        self.address = is.read_string()?;
                    },
                    26 => {
                        self.process_uuid = is.read_string()?;
                    },
                    34 => {
                        self.node_uuid = is.read_string()?;
                    },
                    40 => {
                        self.scope = is.read_enum_or_unknown()?;
                    },
                    50 => {
                        self.pub_type = ::std::option::Option::Some(publisher::Pub_type::MsgPub(is.read_message()?));
                    },
                    58 => {
                        self.pub_type = ::std::option::Option::Some(publisher::Pub_type::SrvPub(is.read_message()?));
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.topic.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.topic);
            }
            if !self.address.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.address);
            }
            if !self.process_uuid.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.process_uuid);
            }
            if !self.node_uuid.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.node_uuid);
            }
            if self.scope != ::protobuf::EnumOrUnknown::new(publisher::Scope::PROCESS) {
                my_size += ::protobuf::rt::int32_size(5, self.scope.value());
            }
            if let ::std::option::Option::Some(ref v) = self.pub_type {
                match v {
                    &publisher::Pub_type::MsgPub(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                    &publisher::Pub_type::SrvPub(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.topic.is_empty() {
                os.write_string(1, &self.topic)?;
            }
            if !self.address.is_empty() {
                os.write_string(2, &self.address)?;
            }
            if !self.process_uuid.is_empty() {
                os.write_string(3, &self.process_uuid)?;
            }
            if !self.node_uuid.is_empty() {
                os.write_string(4, &self.node_uuid)?;
            }
            if self.scope != ::protobuf::EnumOrUnknown::new(publisher::Scope::PROCESS) {
                os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.scope))?;
            }
            if let ::std::option::Option::Some(ref v) = self.pub_type {
                match v {
                    &publisher::Pub_type::MsgPub(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                    },
                    &publisher::Pub_type::SrvPub(ref v) => {
                        ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Publisher {
            Publisher::new()
        }

        fn clear(&mut self) {
            self.topic.clear();
            self.address.clear();
            self.process_uuid.clear();
            self.node_uuid.clear();
            self.scope = ::protobuf::EnumOrUnknown::new(publisher::Scope::PROCESS);
            self.pub_type = ::std::option::Option::None;
            self.pub_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Publisher {
            static instance: Publisher = Publisher {
                topic: ::std::string::String::new(),
                address: ::std::string::String::new(),
                process_uuid: ::std::string::String::new(),
                node_uuid: ::std::string::String::new(),
                scope: ::protobuf::EnumOrUnknown::from_i32(0),
                pub_type: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Publisher {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Discovery.Publisher").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Publisher {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Publisher {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Publisher`
    pub mod publisher {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:gz.msgs.Discovery.Publisher.pub_type)
        pub enum Pub_type {
            // @@protoc_insertion_point(oneof_field:gz.msgs.Discovery.Publisher.msg_pub)
            MsgPub(MessagePublisher),
            // @@protoc_insertion_point(oneof_field:gz.msgs.Discovery.Publisher.srv_pub)
            SrvPub(ServicePublisher),
        }

        impl ::protobuf::Oneof for Pub_type {
        }

        impl ::protobuf::OneofFull for Pub_type {
            fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| <super::Publisher as ::protobuf::MessageFull>::descriptor().oneof_by_name("pub_type").unwrap()).clone()
            }
        }

        impl Pub_type {
            pub(in super::super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
                ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Pub_type>("pub_type")
            }
        }
        #[derive(PartialEq,Clone,Default,Debug)]
        #[derive(::gz_msgs_common::GzMessage)]
        // @@protoc_insertion_point(message:gz.msgs.Discovery.Publisher.MessagePublisher)
        pub struct MessagePublisher {
            // message fields
            // @@protoc_insertion_point(field:gz.msgs.Discovery.Publisher.MessagePublisher.ctrl)
            pub ctrl: ::std::string::String,
            // @@protoc_insertion_point(field:gz.msgs.Discovery.Publisher.MessagePublisher.msg_type)
            pub msg_type: ::std::string::String,
            // @@protoc_insertion_point(field:gz.msgs.Discovery.Publisher.MessagePublisher.throttled)
            pub throttled: bool,
            // @@protoc_insertion_point(field:gz.msgs.Discovery.Publisher.MessagePublisher.msgs_per_sec)
            pub msgs_per_sec: u64,
            // special fields
            // @@protoc_insertion_point(special_field:gz.msgs.Discovery.Publisher.MessagePublisher.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a MessagePublisher {
            fn default() -> &'a MessagePublisher {
                <MessagePublisher as ::protobuf::Message>::default_instance()
            }
        }

        impl MessagePublisher {
            pub fn new() -> MessagePublisher {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "ctrl",
                    |m: &MessagePublisher| { &m.ctrl },
                    |m: &mut MessagePublisher| { &mut m.ctrl },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "msg_type",
                    |m: &MessagePublisher| { &m.msg_type },
                    |m: &mut MessagePublisher| { &mut m.msg_type },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "throttled",
                    |m: &MessagePublisher| { &m.throttled },
                    |m: &mut MessagePublisher| { &mut m.throttled },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "msgs_per_sec",
                    |m: &MessagePublisher| { &m.msgs_per_sec },
                    |m: &mut MessagePublisher| { &mut m.msgs_per_sec },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MessagePublisher>(
                    "Discovery.Publisher.MessagePublisher",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for MessagePublisher {
            const NAME: &'static str = "MessagePublisher";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.ctrl = is.read_string()?;
                        },
                        18 => {
                            self.msg_type = is.read_string()?;
                        },
                        24 => {
                            self.throttled = is.read_bool()?;
                        },
                        32 => {
                            self.msgs_per_sec = is.read_uint64()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.ctrl.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.ctrl);
                }
                if !self.msg_type.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.msg_type);
                }
                if self.throttled != false {
                    my_size += 1 + 1;
                }
                if self.msgs_per_sec != 0 {
                    my_size += ::protobuf::rt::uint64_size(4, self.msgs_per_sec);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.ctrl.is_empty() {
                    os.write_string(1, &self.ctrl)?;
                }
                if !self.msg_type.is_empty() {
                    os.write_string(2, &self.msg_type)?;
                }
                if self.throttled != false {
                    os.write_bool(3, self.throttled)?;
                }
                if self.msgs_per_sec != 0 {
                    os.write_uint64(4, self.msgs_per_sec)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> MessagePublisher {
                MessagePublisher::new()
            }

            fn clear(&mut self) {
                self.ctrl.clear();
                self.msg_type.clear();
                self.throttled = false;
                self.msgs_per_sec = 0;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static MessagePublisher {
                static instance: MessagePublisher = MessagePublisher {
                    ctrl: ::std::string::String::new(),
                    msg_type: ::std::string::String::new(),
                    throttled: false,
                    msgs_per_sec: 0,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for MessagePublisher {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Discovery.Publisher.MessagePublisher").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for MessagePublisher {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for MessagePublisher {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(PartialEq,Clone,Default,Debug)]
        #[derive(::gz_msgs_common::GzMessage)]
        // @@protoc_insertion_point(message:gz.msgs.Discovery.Publisher.ServicePublisher)
        pub struct ServicePublisher {
            // message fields
            // @@protoc_insertion_point(field:gz.msgs.Discovery.Publisher.ServicePublisher.socket_id)
            pub socket_id: ::std::string::String,
            // @@protoc_insertion_point(field:gz.msgs.Discovery.Publisher.ServicePublisher.request_type)
            pub request_type: ::std::string::String,
            // @@protoc_insertion_point(field:gz.msgs.Discovery.Publisher.ServicePublisher.response_type)
            pub response_type: ::std::string::String,
            // special fields
            // @@protoc_insertion_point(special_field:gz.msgs.Discovery.Publisher.ServicePublisher.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a ServicePublisher {
            fn default() -> &'a ServicePublisher {
                <ServicePublisher as ::protobuf::Message>::default_instance()
            }
        }

        impl ServicePublisher {
            pub fn new() -> ServicePublisher {
                ::std::default::Default::default()
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "socket_id",
                    |m: &ServicePublisher| { &m.socket_id },
                    |m: &mut ServicePublisher| { &mut m.socket_id },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "request_type",
                    |m: &ServicePublisher| { &m.request_type },
                    |m: &mut ServicePublisher| { &mut m.request_type },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                    "response_type",
                    |m: &ServicePublisher| { &m.response_type },
                    |m: &mut ServicePublisher| { &mut m.response_type },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServicePublisher>(
                    "Discovery.Publisher.ServicePublisher",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for ServicePublisher {
            const NAME: &'static str = "ServicePublisher";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.socket_id = is.read_string()?;
                        },
                        18 => {
                            self.request_type = is.read_string()?;
                        },
                        26 => {
                            self.response_type = is.read_string()?;
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if !self.socket_id.is_empty() {
                    my_size += ::protobuf::rt::string_size(1, &self.socket_id);
                }
                if !self.request_type.is_empty() {
                    my_size += ::protobuf::rt::string_size(2, &self.request_type);
                }
                if !self.response_type.is_empty() {
                    my_size += ::protobuf::rt::string_size(3, &self.response_type);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if !self.socket_id.is_empty() {
                    os.write_string(1, &self.socket_id)?;
                }
                if !self.request_type.is_empty() {
                    os.write_string(2, &self.request_type)?;
                }
                if !self.response_type.is_empty() {
                    os.write_string(3, &self.response_type)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> ServicePublisher {
                ServicePublisher::new()
            }

            fn clear(&mut self) {
                self.socket_id.clear();
                self.request_type.clear();
                self.response_type.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static ServicePublisher {
                static instance: ServicePublisher = ServicePublisher {
                    socket_id: ::std::string::String::new(),
                    request_type: ::std::string::String::new(),
                    response_type: ::std::string::String::new(),
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for ServicePublisher {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("Discovery.Publisher.ServicePublisher").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for ServicePublisher {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for ServicePublisher {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:gz.msgs.Discovery.Publisher.Scope)
        pub enum Scope {
            // @@protoc_insertion_point(enum_value:gz.msgs.Discovery.Publisher.Scope.PROCESS)
            PROCESS = 0,
            // @@protoc_insertion_point(enum_value:gz.msgs.Discovery.Publisher.Scope.HOST)
            HOST = 1,
            // @@protoc_insertion_point(enum_value:gz.msgs.Discovery.Publisher.Scope.ALL)
            ALL = 2,
        }

        impl ::protobuf::Enum for Scope {
            const NAME: &'static str = "Scope";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<Scope> {
                match value {
                    0 => ::std::option::Option::Some(Scope::PROCESS),
                    1 => ::std::option::Option::Some(Scope::HOST),
                    2 => ::std::option::Option::Some(Scope::ALL),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [Scope] = &[
                Scope::PROCESS,
                Scope::HOST,
                Scope::ALL,
            ];
        }

        impl ::protobuf::EnumFull for Scope {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("Discovery.Publisher.Scope").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for Scope {
            fn default() -> Self {
                Scope::PROCESS
            }
        }

        impl Scope {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Scope>("Discovery.Publisher.Scope")
            }
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:gz.msgs.Discovery.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:gz.msgs.Discovery.Type.UNINITIALIZED)
        UNINITIALIZED = 0,
        // @@protoc_insertion_point(enum_value:gz.msgs.Discovery.Type.ADVERTISE)
        ADVERTISE = 1,
        // @@protoc_insertion_point(enum_value:gz.msgs.Discovery.Type.SUBSCRIBE)
        SUBSCRIBE = 2,
        // @@protoc_insertion_point(enum_value:gz.msgs.Discovery.Type.UNADVERTISE)
        UNADVERTISE = 3,
        // @@protoc_insertion_point(enum_value:gz.msgs.Discovery.Type.HEARTBEAT)
        HEARTBEAT = 4,
        // @@protoc_insertion_point(enum_value:gz.msgs.Discovery.Type.BYE)
        BYE = 5,
        // @@protoc_insertion_point(enum_value:gz.msgs.Discovery.Type.NEW_CONNECTION)
        NEW_CONNECTION = 6,
        // @@protoc_insertion_point(enum_value:gz.msgs.Discovery.Type.END_CONNECTION)
        END_CONNECTION = 7,
        // @@protoc_insertion_point(enum_value:gz.msgs.Discovery.Type.SUBSCRIBERS_REQ)
        SUBSCRIBERS_REQ = 8,
        // @@protoc_insertion_point(enum_value:gz.msgs.Discovery.Type.SUBSCRIBERS_REP)
        SUBSCRIBERS_REP = 9,
    }

    impl ::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::UNINITIALIZED),
                1 => ::std::option::Option::Some(Type::ADVERTISE),
                2 => ::std::option::Option::Some(Type::SUBSCRIBE),
                3 => ::std::option::Option::Some(Type::UNADVERTISE),
                4 => ::std::option::Option::Some(Type::HEARTBEAT),
                5 => ::std::option::Option::Some(Type::BYE),
                6 => ::std::option::Option::Some(Type::NEW_CONNECTION),
                7 => ::std::option::Option::Some(Type::END_CONNECTION),
                8 => ::std::option::Option::Some(Type::SUBSCRIBERS_REQ),
                9 => ::std::option::Option::Some(Type::SUBSCRIBERS_REP),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::UNINITIALIZED,
            Type::ADVERTISE,
            Type::SUBSCRIBE,
            Type::UNADVERTISE,
            Type::HEARTBEAT,
            Type::BYE,
            Type::NEW_CONNECTION,
            Type::END_CONNECTION,
            Type::SUBSCRIBERS_REQ,
            Type::SUBSCRIBERS_REP,
        ];
    }

    impl ::protobuf::EnumFull for Type {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Discovery.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::UNINITIALIZED
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Type>("Discovery.Type")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x17gz/msgs/discovery.proto\x12\x07gz.msgs\x1a\x14gz/msgs/header.proto\
    \"\xd5\t\n\tDiscovery\x12'\n\x06header\x18\x01\x20\x01(\x0b2\x0f.gz.msgs\
    .HeaderR\x06header\x12\x18\n\x07version\x18\x02\x20\x01(\rR\x07version\
    \x12!\n\x0cprocess_uuid\x18\x03\x20\x01(\tR\x0bprocessUuid\x12+\n\x04typ\
    e\x18\x04\x20\x01(\x0e2\x17.gz.msgs.Discovery.TypeR\x04type\x12.\n\x05fl\
    ags\x18\x05\x20\x01(\x0b2\x18.gz.msgs.Discovery.FlagsR\x05flags\x121\n\
    \x03sub\x18\x06\x20\x01(\x0b2\x1d.gz.msgs.Discovery.SubscriberH\0R\x03su\
    b\x120\n\x03pub\x18\x07\x20\x01(\x0b2\x1c.gz.msgs.Discovery.PublisherH\0\
    R\x03pub\x1a8\n\x05Flags\x12\x14\n\x05relay\x18\x01\x20\x01(\x08R\x05rel\
    ay\x12\x19\n\x08no_relay\x18\x02\x20\x01(\x08R\x07noRelay\x1a\"\n\nSubsc\
    riber\x12\x14\n\x05topic\x18\x01\x20\x01(\tR\x05topic\x1a\xfb\x04\n\tPub\
    lisher\x12\x14\n\x05topic\x18\x01\x20\x01(\tR\x05topic\x12\x18\n\x07addr\
    ess\x18\x02\x20\x01(\tR\x07address\x12!\n\x0cprocess_uuid\x18\x03\x20\
    \x01(\tR\x0bprocessUuid\x12\x1b\n\tnode_uuid\x18\x04\x20\x01(\tR\x08node\
    Uuid\x128\n\x05scope\x18\x05\x20\x01(\x0e2\".gz.msgs.Discovery.Publisher\
    .ScopeR\x05scope\x12H\n\x07msg_pub\x18\x06\x20\x01(\x0b2-.gz.msgs.Discov\
    ery.Publisher.MessagePublisherH\0R\x06msgPub\x12H\n\x07srv_pub\x18\x07\
    \x20\x01(\x0b2-.gz.msgs.Discovery.Publisher.ServicePublisherH\0R\x06srvP\
    ub\x1a\x81\x01\n\x10MessagePublisher\x12\x12\n\x04ctrl\x18\x01\x20\x01(\
    \tR\x04ctrl\x12\x19\n\x08msg_type\x18\x02\x20\x01(\tR\x07msgType\x12\x1c\
    \n\tthrottled\x18\x03\x20\x01(\x08R\tthrottled\x12\x20\n\x0cmsgs_per_sec\
    \x18\x04\x20\x01(\x04R\nmsgsPerSec\x1aw\n\x10ServicePublisher\x12\x1b\n\
    \tsocket_id\x18\x01\x20\x01(\tR\x08socketId\x12!\n\x0crequest_type\x18\
    \x02\x20\x01(\tR\x0brequestType\x12#\n\rresponse_type\x18\x03\x20\x01(\t\
    R\x0cresponseType\"'\n\x05Scope\x12\x0b\n\x07PROCESS\x10\0\x12\x08\n\x04\
    HOST\x10\x01\x12\x07\n\x03ALL\x10\x02B\n\n\x08pub_type\"\xb2\x01\n\x04Ty\
    pe\x12\x11\n\rUNINITIALIZED\x10\0\x12\r\n\tADVERTISE\x10\x01\x12\r\n\tSU\
    BSCRIBE\x10\x02\x12\x0f\n\x0bUNADVERTISE\x10\x03\x12\r\n\tHEARTBEAT\x10\
    \x04\x12\x07\n\x03BYE\x10\x05\x12\x12\n\x0eNEW_CONNECTION\x10\x06\x12\
    \x12\n\x0eEND_CONNECTION\x10\x07\x12\x13\n\x0fSUBSCRIBERS_REQ\x10\x08\
    \x12\x13\n\x0fSUBSCRIBERS_REP\x10\tB\x0f\n\rdisc_contentsB\x1e\n\x0bcom.\
    gz.msgsB\x0fDiscoveryProtosb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::header::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(6);
            messages.push(Discovery::generated_message_descriptor_data());
            messages.push(discovery::Flags::generated_message_descriptor_data());
            messages.push(discovery::Subscriber::generated_message_descriptor_data());
            messages.push(discovery::Publisher::generated_message_descriptor_data());
            messages.push(discovery::publisher::MessagePublisher::generated_message_descriptor_data());
            messages.push(discovery::publisher::ServicePublisher::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(discovery::Type::generated_enum_descriptor_data());
            enums.push(discovery::publisher::Scope::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
